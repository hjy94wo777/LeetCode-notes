	### 二叉树种类
- 满二叉树
![[Pasted image 20230306103306.png]]
- 完全二叉树
![[Pasted image 20230306103344.png]]
- 二叉搜索数
	-   若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
	-   若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
![[Pasted image 20230306103409.png]]
- 平衡二叉搜索树
它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树
![[Pasted image 20230306103529.png]]
### 二叉树遍历
-   深度优先遍历
    -   前序遍历（递归法，迭代法）中左右
    -   中序遍历（递归法，迭代法）左中右
    -   后序遍历（递归法，迭代法）左右中
-   广度优先遍历
    -   层次遍历（迭代法）
### 二叉树定义
```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

### 二叉树前中后序遍历
#### LeetCode [144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)
递归法
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> res;
    vector<int> preorderTraversal(TreeNode* root) {
        dfs(root);
        return res;
    }

    void dfs(TreeNode* node) {
        if (node == nullptr) return;

        res.push_back(node->val);
        dfs(node->left);
        dfs(node->right);
    }

};
```
迭代法
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> res;
    vector<int> preorderTraversal(TreeNode* root) {
        if (!root) return res;
        stack<TreeNode*> st;
        while (root || !st.empty()) {
            while (root) {
                res.push_back(root->val);
                st.push(root);
                root = root->left;
            }
            root = st.top();
            st.pop();
            root = root->right;
        }
        return res;
    }
};
```
#### LeetCode [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)
递归法
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> res;
    vector<int> inorderTraversal(TreeNode* root) {
        dfs(root);
        return res;
    }

    void dfs(TreeNode* node) {
        if (node == nullptr) return;
        dfs(node->left);
        res.push_back(node->val);
        dfs(node->right);
    } 
};
```
迭代法
维护一个stack
在stack里一直加入root左节点
每次弹出stack中一个节点并赋值给root
最后root赋值root右节点
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> res;
    vector<int> inorderTraversal(TreeNode* root) {
        if (!root) return res;
        stack<TreeNode*> st;
        while (root || !st.empty()) {
            while (root) {
                st.push(root);
                root = root->left;
            }
            root = st.top();
            st.pop();
            res.push_back(root->val);
            root = root->right;
        }
        return res;
    }
};
```
#### LeetCode [145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)
递归法
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> res;
    vector<int> postorderTraversal(TreeNode* root) {
        dfs(root);
        return res;
    }

    void dfs(TreeNode* node) {
        if (node == nullptr) return;

        dfs(node->left);
        dfs(node->right);
        res.push_back(node->val);
    }
};
```
迭代法
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> res;
    vector<int> postorderTraversal(TreeNode* root) {
        if (!root) return res;
        stack<TreeNode*> st;
        TreeNode* pre = nullptr;
        while (root || !st.empty()) {
            while (root) {
                st.push(root);
                root = root->left;
            }
            root = st.top();
            st.pop();
            if (root->right == nullptr || root->right == pre) {
                res.push_back(root->val);
                pre = root;
                root = nullptr;
            }
            else {
                st.push(root);
                root = root->right;
            }
        }
        return res;
    }
};
```
### 二叉树层序遍历及其应用
#### LeetCode [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)
维护一个queue
遍历每一层，记录`size`
每一层弹出queue最上面node并加入该node的左右节点（若有）
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

class Solution {
public:
    vector<vector<int>> res;
    vector<vector<int>> levelOrder(TreeNode* root) {
        if (root == nullptr) return res;

        queue<TreeNode*> que;
        que.push(root); 

        while (!que.empty()) {
            int size = que.size();
            vector<int> path;

            for (int i = 0; i < size; i ++) {
                TreeNode* temp = que.front();
                que.pop();
                path.push_back(temp->val);
                if (temp->left) que.push(temp->left);
                if (temp->right) que.push(temp->right);
            }
            res.push_back(path);
        }

        return res;
    }
};
```
#### LeetCode  [107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)
步骤与上面相同
最后反转一下`res`
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> res;
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        if (root == nullptr) return res;

        queue<TreeNode*> que;
        que.push(root);

        while (!que.empty()) {
            int size = que.size();
            vector<int> path;

            for (int i = 0; i < size; i ++) {
                TreeNode* temp = que.front();
                que.pop();
                path.push_back(temp->val);
                if (temp->left) que.push(temp->left);
                if (temp->right) que.push(temp->right);
            }
            res.push_back(path);
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```
#### LeetCode [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)
从右边看能看到二叉树的值，即每层最后一个子树
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> res;
    vector<int> rightSideView(TreeNode* root) {
        if (root == nullptr) return res;

        queue<TreeNode*> que;
        que.push(root);

        while (!que.empty()) {
            int size = que.size();
            
            for (int i = 0; i < size; i ++) {
                TreeNode* temp = que.front();
                que.pop();
            
            
                if (i == (size - 1)) res.push_back(temp->val);
                if (temp->left) que.push(temp->left);
                if (temp->right) que.push(temp->right); 
            }
        }

        return res;
    }
};
```
#### LeetCode [637. 二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<double> res;
    vector<double> averageOfLevels(TreeNode* root) {
        queue<TreeNode*> que;

        que.push(root);

        while (!que.empty()) {
            int size = que.size();

            vector<double> path;
            for (int i = 0; i < size; i ++) {
                TreeNode* temp = que.front();
                que.pop();
                path.push_back(temp->val);
                if (temp->left) que.push(temp->left);
                if (temp->right) que.push(temp->right);
            } 
            double sum = 0;
            for (int i = 0; i < path.size(); i ++) {
                sum += path[i];
            }

            res.push_back(sum / path.size());
        }
        return res;
    }
};
```
#### LeetCode [429. N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)
N叉树加一个子树循环
```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    vector<vector<int>> res;
    vector<vector<int>> levelOrder(Node* root) {
        if (root == nullptr) return res;

        queue<Node*> que;
        que.push(root);

        
        while (!que.empty()) {
            int size = que.size();
           
            vector<int> path;
            for (int i = 0; i < size; i ++) {
                Node* temp = que.front();
                que.pop();
                path.push_back(temp->val);
                for (int j = 0; j < temp->children.size(); j ++)
                    if (temp->children[j]) que.push(temp->children[j]);
            }
            res.push_back(path);
        }
        return res;
    }
};
```
#### LeetCode [515. 在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)
sort
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> res;
    vector<int> largestValues(TreeNode* root) {
        if (root == nullptr) return res;

        queue<TreeNode*> que;
        que.push(root);

        while (!que.empty()) {
            int size = que.size();
            vector<int> path;

            for (int i = 0; i < size; i ++) {
                TreeNode* temp = que.front();
                que.pop();

                path.push_back(temp->val);
                if (temp->left) que.push(temp->left);
                if (temp->right) que.push(temp->right);
            }
            sort(path.begin(), path.end());
            res.push_back(path[path.size() - 1]);
        }

        return res;
    }
};
```
不用`sort`和`path`
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> res;
    vector<int> largestValues(TreeNode* root) {
        if (root == nullptr) return res;

        queue<TreeNode*> que;
        que.push(root);

        while (!que.empty()) {
            int size = que.size();
           
            int max_value = pow(-2, 31); // INT_MIN

            for (int i = 0; i < size; i ++) {
                TreeNode* temp = que.front();
                que.pop();

                max_value = temp->val > max_value ? temp->val: max_value;
                if (temp->left) que.push(temp->left);
                if (temp->right) que.push(temp->right);
            }
            res.push_back(max_value);
        }

        return res;
    }
};
```




#### LeetCode [116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)
```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
        if (root == NULL) return root;
        queue<Node*> que;
        que.push(root);

        while(!que.empty()) {
            int size = que.size();

            Node* nodePre;
            Node* node;
            for (int i = 0; i < size; i ++) {
                if (i == 0) { 
                    nodePre = que.front();
                    que.pop();
                    node = nodePre; // 只有一层这种情况
                }
                else {
                    node = que.front();
                    que.pop();
                    nodePre->next = node; //nodepre指向当前node
                    nodePre = nodePre->next; //nodepre后移一位
                }
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            nodePre->next = NULL; // 最后一个node指向空
        } 
        return root;
    }
};
```
#### LeetCode [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)
```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;


    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
       if (root == NULL) return root;
       queue<Node*> que;
        que.push(root);

        while (!que.empty()) {
            int size = que.size();
            Node* node;
            Node* nodepre;
            for (int i = 0; i < size; i ++) {
                if (i == 0) {
                    nodepre = que.front();
                    que.pop();
                    node = nodepre;
                }
                else {
                    node = que.front();
                    que.pop();
                    nodepre->next = node;
                    nodepre = nodepre->next;
                }

                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            nodepre->next = NULL;
        }
        return root;
    }
};
```
#### LeetCode [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 * 
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int depth = 0;
    int maxDepth(TreeNode* root) {
        if (root == nullptr) return depth;

        queue<TreeNode*> que;
        que.push(root);

        while (!que.empty()) {
            int size = que.size();
            for (int i = 0; i < size; i ++) {
                TreeNode* temp = que.front();
                que.pop();
                if (temp->left) que.push(temp->left);
                if (temp->right) que.push(temp->right);
            }
            depth ++;
        }

        return depth;
    }
};
```
递归
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == nullptr) return 0;
        return 1 + max(maxDepth(root->left), maxDepth(root->right));
    }
};
```
#### LeetCode [111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)
当当前节点没有左右子树返回答案
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int depth = 0;
    int minDepth(TreeNode* root) {
        if (root == nullptr) return depth;

        queue<TreeNode*> que;
        que.push(root);

        while(!que.empty()) {
            int size = que.size();
            depth ++;
            for (int i = 0; i < size; i ++) {
                TreeNode* temp = que.front();
                que.pop();
                if (!temp->left && !temp->right) return depth;
                if (temp->left) que.push(temp->left);
                if (temp->right) que.push(temp->right);
            }
        }
        return depth;
    }
};
```
递归
当左右节点都为空时才为最小深度
```c++
/**

* Definition for a binary tree node.

* struct TreeNode {

* int val;

* TreeNode *left;

* TreeNode *right;

* TreeNode() : val(0), left(nullptr), right(nullptr) {}

* TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

* TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}

* };

*/

class Solution {

public:

int minDepth(TreeNode* root) {

if (root == nullptr) return 0;

if (root->left != nullptr && root->right == nullptr) {

return 1 + minDepth(root->left);

}

if (root->right != nullptr && root->left == nullptr) {

return 1 + minDepth(root->right);

}

return 1 + min(minDepth(root->left), minDepth(root->right));

}

};
```
#### LeetCode [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)
层序遍历每一层swap左右孩子
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == nullptr) return root;
        queue<TreeNode*> que;
        que.push(root);

        while (!que.empty()) {
            int size = que.size();

            for (int i = 0; i < size; i ++) {
                TreeNode* temp = que.front();
                que.pop();
                swap(temp->left, temp->right);
                if (temp->left) que.push(temp->left);
                if (temp->right) que.push(temp->right);
            }
        }
        return root;
    }
};
```
### 其他
#### LeetCode [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)
递归法
递归左右两节点
判断当前左右节点是否相同或为空
判断外层内层节点是否相同
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == nullptr) return true;
        return compare(root->left, root->right);
    }

    bool compare(TreeNode* left, TreeNode* right) {
        if (left == nullptr && right != nullptr) return false;
        else if (left != nullptr && right == nullptr) return false;
        else if (left == nullptr && right == nullptr) return true;
        else if (left->val != right->val) return false;


        bool outside = compare(left->left, right->right);
        bool inside = compare(left->right, right->left);

        return outside && inside;
    }
};
```
迭代法
维护一个`que`
分别加入左右节点，取出两个节点判断是否相同或为空
最后依次加入外层(左节点的左子树，右节点的右子树)，内层(左节点的右子树，右节点的左子树)
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == nullptr) return root;
        queue<TreeNode*> que;
        que.push(root->left);
        que.push(root->right);

        while (!que.empty()) {
            TreeNode* leftNode = que.front();
            que.pop();
            TreeNode* rightNode = que.front();
            que.pop();

            if (
            !leftNode && !rightNode) continue;
            if (!leftNode || !rightNode || leftNode->val != rightNode->val) return false;

            que.push(leftNode->left);
            que.push(rightNode->right);
            que.push(leftNode->right);
            que.push(rightNode->left);
        }
        return true;

    }
};
```


#### LeetCode [222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)
递归
左节点数量+右节点数量+中间节点数量
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == nullptr) return 0;
        return 1 + countNodes(root->left) + countNodes(root->right);
    }
};
```

#### LeetCode [110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)
![[Pasted image 20230307112425.png]]
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        return getHeight(root) == -1 ? false: true;
    }

    int getHeight(TreeNode* node) {
	    if (node == nullptr) return 0;
        int leftHeight = getHeight(node->left);
        if (leftHeight == -1) return -1;
        int rightHeigth = getHeight(node->right);
        if (rightHeigth == -1) return -1;
        return abs(leftHeight - rightHeigth) > 1 ? -1: 1 + max(leftHeight, rightHeigth);
    }
};
```
#### LeetCode [257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)
dfs
当左右子树都为空是return
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> path;
    vector<string> res;
    vector<string> binaryTreePaths(TreeNode* root) {
        dfs(root);
        return res;
    }

    void dfs(TreeNode* node) {
        path.push_back(node->val); //写这里是因为最后一个节点也要加入
        if (node->left == nullptr && node->right == nullptr) {
            string str;
            for (int i = 0; i < path.size() - 1; i ++) {
                str += to_string(path[i]);
                str.append("->");
            }
            str += to_string(path[path.size() - 1]);
            res.push_back(str);
            return;
        }

        
        if (node->left) {
            dfs(node->left);
            path.pop_back();
        } 
        

        if (node->right) {
            dfs(node->right);
            path.pop_back();
        }
    }
};
```
#### LeetCode [404. 左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/)
左叶子条件为：
1. 节点左子树存在
2. 左子树的左右子树都不存在
不需要回溯！！！
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int sum;
    int sumOfLeftLeaves(TreeNode* root) {
        dfs(root);

        return sum;
    }
    void dfs(TreeNode* node) {
        if (!node) return;
        if (node->left) {
            if (!node->left->left && !node->left->right) {
                sum += node->left->val;
            }
        }
            
        dfs(node->left);
        dfs(node->right);
    }
};
```
#### LeetCode [513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)
难度中等442
层序遍历
最后一层的第一个数即为最左边的数
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int res;
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> que;
        que.push(root);

        while (!que.empty()) {
            int size = que.size();

            for (int i = 0; i < size; i ++) {
                TreeNode* temp = que.front();
                que.pop();
                if (i == 0) res = temp->val; 
                if (temp->left) que.push(temp->left);
                if (temp->right) que.push(temp->right);
            }
        }

        return res;
    }
};
```
#### LeetCode [112. 路径总和](https://leetcode.cn/problems/path-sum/)
递归
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if (!root) return false;
        if (!root->left && !root->right) return root->val == targetSum;
        if (root->left && hasPathSum(root->left, targetSum - root->val)) return true;
        if (root->right && hasPathSum(root->right, targetSum - root->val)) return true;
        return false;
    }
};
```

dfs
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int sum;
    bool hasPathSum(TreeNode* root, int targetSum) {
        if (root == nullptr) return false;
        return dfs(root, targetSum - root->val);
    }

    bool dfs(TreeNode* root, int targetSum) {
        if (!root) return false;
        if (!root->left && !root->right) {
            return sum == targetSum;
        } 

        if (root->left) {
            sum += root->left->val;
            if (dfs(root->left, targetSum)) return true;
            sum -= root->left->val;
        } 
        

        if (root->right) {
            sum += root->right->val;
            if (dfs(root->right, targetSum)) return true;
            sum -= root->right->val;
        } 

        return false;
            
    }
};
```
#### LeetCode [113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)
dfs与上题类似
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int sum;
    vector<int> path;
    vector<vector<int>> res;
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        if (!root) return res;
        sum += root->val;
        path.push_back(root->val);
        dfs(root, targetSum);
        return res;
    }

    void dfs(TreeNode* root, int targetSum) {
        if (!root) return;
        if (!root->left && !root->right) {
            if (sum == targetSum) {
                res.push_back(path);
            }
        }

        if (root->left) {
            sum += root->left->val;
            path.push_back(root->left->val);
            dfs(root->left, targetSum);
            sum -= root->left->val;
            path.pop_back();
        }

        if (root->right) {
            sum += root->right->val;
            path.push_back(root->right->val);
            dfs(root->right, targetSum);
            sum -= root->right->val;
            path.pop_back();
        }
    }
};
```
#### LeetCode [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)
dfs思路与前两题类似以每个节点为根节点dfs计数
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    long long sum;
    int res;
    int pathSum(TreeNode* root, int targetSum) {
        dfs_t(root, targetSum);
        return res;
    }
    void dfs(TreeNode* root, int targetSum) {
        if (!root) return;
        if (sum == targetSum) res ++;
        if (root->left) {
            sum += root->left->val;
            dfs(root->left, targetSum);
            sum -= root->left->val;
        } 
        if (root->right) {
            sum += root->right->val;
            dfs(root->right, targetSum);
            sum -= root->right->val;
        } 
    }

    void dfs_t(TreeNode* root, int targetSum) {
        if (!root) return;
        dfs(root, targetSum-root->val);
        dfs_t(root->left, targetSum);
        dfs_t(root->right, targetSum);
    }
};
```
#### LeetCode [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
先在前序遍历中找到根节点后进行递归找左右子树
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    unordered_map<int, int> pos;
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        for (int i = 0; i < inorder.size(); i ++) pos[inorder[i]] = i;
        return dfs(preorder, inorder, 0, preorder.size() - 1, 0, inorder.size() - 1);
    }

    TreeNode* dfs(vector<int>& preorder, vector<int>& inorder, int pl, int pr, int il, int ir) {
        if (pl > pr) return nullptr;
        auto root = new TreeNode(preorder[pl]);
        int k = pos[preorder[pl]];
        root->left = dfs(preorder, inorder, pl + 1, pl + 1 + k - il - 1, il, k - 1);
        root->right = dfs(preorder, inorder, pl + 1 + k - il - 1 + 1, pr, k + 1, ir);
        return root;
    }
};
```
#### LeetCode [106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)
同上先找后序遍历根节点即最后一个数
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    unordered_map<int, int> pos;
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        for (int i = 0; i < inorder.size(); i ++) pos[inorder[i]] = i;
        return dfs(inorder, postorder, 0, postorder.size() - 1, 0, inorder.size() - 1);
    }

    TreeNode* dfs(vector<int>& inorder, vector<int>& postorder, int pl, int pr, int il, int ir) {
        if (pl > pr) return nullptr;
        TreeNode* root = new TreeNode(postorder[pr]);
        int k = pos[postorder[pr]];
        root->left = dfs(inorder, postorder, pl, pl + k - il - 1, il, k - 1);
        root->right = dfs(inorder, postorder, pl + k - il, pr - 1, k + 1, ir);
        return root;
    }
};
```
#### LeetCode [654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)
思路与前两题类似
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int pos[1010];
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        for (int i = 0; i < nums.size(); i ++) pos[nums[i]] = i;
        return dfs(nums, 0, nums.size() - 1);
    }

    TreeNode* dfs(vector<int>& nums, int start, int end) {
        if (start > end) return nullptr;
        TreeNode* root = new TreeNode(max(nums, start, end));
        int k = pos[max(nums, start, end)];
        root->left = dfs(nums, start, k - 1);
        root->right = dfs(nums, k + 1, end);
        return root;
    }

    int max(vector<int>& nums, int start, int end) {
        int max = 0;
        for (int i = start; i <= end; i ++) {
            if (nums[i] > max) max = nums[i];
        }
        return max;
    }
};
```
#### LeetCode [617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if (root2) swap(root1, root2); //先交换t1, t2。保证t1一定不为空
        if (!root1) return nullptr;
        if (root2) root1->val += root2->val;
        root1->left = mergeTrees(root1->left, root2 ? root2->left: nullptr);
        root1->right = mergeTrees(root1->right, root2 ? root2->right: nullptr);
        return root1;
    }
};
```
#### LeetCode [700. 二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)
利用二叉搜索树的性质

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if (root == nullptr || root->val == val) return root;
        if (root->val > val) return searchBST(root->left, val);
        if (root->val < val) return searchBST(root->right, val);
        return root;
    }
};
```
#### LeetCode [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)
中序遍历添加进数组后判断
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> vec;
    bool isValidBST(TreeNode* root) {
        dfs(root);
        for (int i = 1; i < vec.size(); i ++) {
            if (vec[i] <= vec[i - 1]) return false;
        }

        return true;
    }

    void dfs(TreeNode* node) {
        if (node == nullptr) return;
        dfs(node->left);
        vec.push_back(node->val);
        dfs(node->right);
    }


};
```
#### LeetCode [530. 二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)
同上，中序遍历为有序数组后遍历数组找最小差值
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> vec;
    int getMinimumDifference(TreeNode* root) {
        dfs(root);
        int min = 100000;
        for (int i = 1; i < vec.size(); i ++) {
            int temp = vec[i] - vec[i - 1];
            min = min < temp? min: temp;
        }

        return min;
    }

    void dfs(TreeNode* root) {
        if (root == nullptr) return;
        dfs(root->left);
        vec.push_back(root->val);
        dfs(root->right);
    }

    
};
```
#### LeetCode [501. 二叉搜索树中的众数](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)
中序遍历，记录当前数字出现次数以及最多数字出现次数以及上一个数字
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> res;
    int maxc = 0, curc = 0, last;
    vector<int> findMode(TreeNode* root) {
        dfs(root);
        return res;
    }

    void dfs(TreeNode* node) {
        if (!node) return;
        dfs(node->left);
        if (!curc || node->val == last) { //第一个数字活出现相同数字
            curc ++;
            last = node->val;
        }
        else {
            curc = 1;
            last = node->val;
        }
        if (curc > maxc) {
            maxc = curc;
            res = {last};
        }
        else if (curc == maxc) {
            res.push_back(last);
        }
        dfs(node->right);
    }
};
```

#### LeetCode [235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)
先让p一定在左子树，q一定在右子树
后分三种情况讨论：
1. p,q分别在左右子树或在根节点直接返回根节点
2. p,q都在左子树递归左子树
3. p,q都在右子树递归右子树
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (p->val > q->val) swap(p, q);
        if (p->val <= root->val && q->val >= root->val) return root;
        if (q->val < root->val) return lowestCommonAncestor(root->left, p, q);
        return lowestCommonAncestor(root->right, p, q);
    }
};
```
#### LeetCode [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)
![[Pasted image 20230313104431.png]]
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == NULL || root == p || root == q) return root; //包含root为空
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if (left != NULL && right != NULL) return root;
        if (left == NULL) return right;
        return left;
    }
};
```
#### LeetCode [701. 二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)
根据插入值大小递归遍历左右子树，当子树为空时插入在这个空地方并返回
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if (root == nullptr) {
            TreeNode* node = new TreeNode(val);
            return node;
        }

        if (val < root->val) root->left = insertIntoBST(root->left, val);
        if (val > root->val) root->right = insertIntoBST(root->right, val);
        return root;
    }
};
```
#### LeetCode [450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)
![[Pasted image 20230313112430.png]]
1. `当前节点值==key值`
	1. 没有左右子树：删除该节点 `root = null`
	2. 没有左子树：将右子树赋值到root `root = root->right`
	3. 没有右子树：将左子树赋值到root `root = root->left`
	4. 有左右子树：
		1. 找到节点后继 
			`auto p = root->right; while(p->left) p = p->left`
		2. 后继赋值到root
			`right->val = p->val`
		3. 删除后继（后继一定没有左子树）
			`del(root->val, p->val)`
1. `当前节点值<key值` 递归右子树
2. `当前节点值>key值` 递归左子树
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        del(root, key);
        return root;
    }

    void del(TreeNode* &root, int key) {
        if (!root) return;
        if (root->val == key) {
            if (!root->left && !root->right) root = NULL; //左右儿子都为空
            else if (!root->left) root = root->right; // 左儿子为空
            else if (!root->right) root = root->left; // 右儿子为空
            else { // 左右儿子都不为空
                auto p = root->right;
                while (p->left) p = p->left; //找到root的后继
                root->val = p->val; //将后继赋值给root
                del(root->right, p->val);
            }
        }   
        else if (key < root->val) del(root->left, key);
        else del(root->right, key); 
    }
};
```
#### LeetCode [669. 修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/)
1. root值小于low，则说明左子节点值一定小于low，则返回右子树
2. root值大于high同理
3. 最后root左右节点分别接收其返回值
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if (!root) return nullptr;
        if (root->val < low) return trimBST(root->right, low, high);
        if (root->val > high) return trimBST(root->left, low, high);
        root->left = trimBST(root->left, low, high);
        root->right = trimBST(root->right, low, high);
        return root;
    }
};
```
#### LeetCode [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)
以中点mid为根节点建树
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return build(nums, 0, nums.size() - 1);
    }

    TreeNode* build(vector<int>& nums, int l, int r) {
        if (l > r) return nullptr;
        int mid = l + r >> 1;
        auto root = new TreeNode(nums[mid]);
        root->left = build(nums, l, mid - 1);
        root->right = build(nums, mid + 1, r);
        return root;
    }
};
```
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> vals;
    map<int, int> map;

    TreeNode* convertBST(TreeNode* root) {
        get_vals(root);

        int sum = 0;
        for (int i = vals.size() - 1; i >= 0; i --) {
            sum += vals[i];
            map[vals[i]] = sum;
        }
        dfs(root);
        return root;
    }

    void get_vals(TreeNode* root) {
        if (!root) return;
        get_vals(root->left);
        vals.push_back(root->val);
        get_vals(root->right);
    }

    void dfs(TreeNode* root) {
        if (!root) return;
        dfs(root->left);
        root->val = map[root->val];
        dfs(root->right);
    }
};
```
#### LeetCode[114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)
模拟
![[Pasted image 20230318154421.png]]
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void flatten(TreeNode* root) {
        while (root) {
            auto p = root->left;
            if(p) {
                while (p->right) p = p->right;
                p->right = root->right;
                root->right = root->left;
                root->left = nullptr;
            }
            root = root->right;
        }
    }
};
```
#### LeetCode [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)
dfs返回左右两条路径加上当前节点最大值
dfs中添加res
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int res;
    int maxPathSum(TreeNode* root) {
        res = INT_MIN;
        dfs(root);
        return res;
    }

    int dfs(TreeNode* u) {
        if (!u) return 0;
        int left = max(0, dfs(u->left)), right = max(0, dfs(u->right));
        res = max(res, u->val + left + right);
        return u->val + max(left, right);
    }
};
```


#### LeetCode [297. 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Codec {
public:

    // Encodes a tree to a single string.
    string path;
    string serialize(TreeNode* root) {
        dfs_s(root);
        return path;
    }

    void dfs_s(TreeNode* root) {
        if (!root) path += "#,";
        else {
            path += to_string(root->val) + ',';
            dfs_s(root->left);
            dfs_s(root->right);
        }
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        int u = 0;
        return dfs_d(data, u);
    }

    TreeNode* dfs_d(string& data, int& u) {
        if (data[u] == '#') {
            u += 2;
            return NULL;
        }
        else {
            int k = u;
            while (data[u] != ',') u ++;
            auto root = new TreeNode(stoi(data.substr(k, u - k)));
            u ++;
            root->left = dfs_d(data, u);
            root->right = dfs_d(data, u);
            return root;
        }
        
    }
};

// Your Codec object will be instantiated and called as such:
// Codec ser, deser;
// TreeNode* ans = deser.deserialize(ser.serialize(root));
```